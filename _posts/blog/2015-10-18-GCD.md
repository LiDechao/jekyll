---
layout:     post
title:      Grand Central Dispatch (GCD)
category:   blog
description: Grand Central Dispatch(GCD)是异步执行任务的技术之一。能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能；而且，提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱；具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。

---
##Dispatch Queue

|Dispatch Queue的种类|说明|
|:---:|:---:|
|Serial Dispatch Queue|等待现在执行中处理结束|
|Concurrent Dispatch Queue|不等待现在执行中处理结束|

##Dispatch Queue Create

	dispatch_queue_t serial = dispatch_queue_create("",
		 DISPATCH_QUEUE_SERIAL); //串行队列,默认
    dispatch_queue_t concurrent = dispatch_queue_create("",
    	 DISPATCH_QUEUE_CONCURRENT); //并行队列
	
第一个参数为名字，推荐使用程序ID或逆序全程域名的。

##Main Dispatch Queue/Global Dispatch Queue
Main Dispatch Queue是在主线程执行的，为Serial Dispatch Queue。获取方式为：

	dispatch_queue_t mainQueue = dispatch_get_main_queue();
	
Global Dispatch Queue分为高优先级（High Priority）、默认优先级（Default Priority）、低优先级（Low Priority）和后台优先级（Background Priority）。获取方法为：

	dispatch_queue_t globalHigh =
	 	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
    dispatch_queue_t globalDefault =
     	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_queue_t globalLow =
     	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
    dispatch_queue_t globalBackground =
     	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
     	
根据文档描述

```
Returns a system-defined global concurrent queue with the specified quality of service class.
```

可知 global queue都是concurrent queue。
     	
##Dispatch Set Target Queue
dispatch_set_target_queue(Q1,Q2);
Q1为需要修改优先级的，Q2为Q1要与他同级的。
MainDQ 与GlobalDQ因为是全局 所以无法作为第一个参数。

在必须将不可并行的处理追加到多个Serial Dispatch Queue 中时，如果使用dispatch_set_target_queue函数将目标指定为某一个Serial Dispatch Queue即可防止处理并行执行。

##Dispatch After 与 Dispatch Walltime

     dispatch_after 为延迟多久加入队列（相对时间）
     dispatch_walltime 为在什么时间加入队列（绝对时间）
     
使用：

	dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 
										3ull * NSEC_PER_SEC);
    dispatch_after(time, dispatch_get_main_queue(), ^{
    	NSLog(@"dispatch_after");
    });
    
**强调:**

**dispatch_after是延迟提交，不是延迟运行**，指的就是将一个Block在特定的延时以后，加入到指定的队列中，**不是在特定的时间后立即运行！**
    
注意dispatch_time_t：

	dispatch_time_t dispatch_time ( dispatch_time_t when, 
									int64_t delta );

第一个参数一般是 **DISPATCH_TIME_NOW** ，表示从现在开始。
那么第二个参数就是真正的延时的具体时间。

这里要特别注意的是，delta参数是“纳秒！”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下：

	#define NSEC_PER_SEC 1000000000ull
	#define NSEC_PER_MSEC 1000000ull
	#define USEC_PER_SEC 1000000ull
	#define NSEC_PER_USEC 1000ull
	
关键词解释：

* NSEC：纳秒。
* USEC：微妙。
* SEC：秒
* MSEC：兆秒
* PER：每

所以：

1. NSEC_PER_SEC，每秒有多少纳秒。
2. NSEC_PER_MSEC，每兆秒有多少纳秒。
2. USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）
3. NSEC_PER_USEC，每毫秒有多少纳秒。

所以，延时 **1秒** 可以写成如下形式：

	dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);
	dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);
	dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC);
	
趣味测试：猜猜下面的输出顺序	

```
- (void)testSequence {
    NSLog(@"%d", 1);    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0), dispatch_get_main_queue(), ^{
        NSLog(@"%d", 2);
    });
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"%d", 3);
    });
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0), dispatch_get_main_queue(), ^{
        NSLog(@"%d", 4);
    });
    [self performSelector:@selector(perform) withObject:nil afterDelay:0]; // ? runloop里的事件何时执行 
    NSLog(@"%d", 5);
}
- (void)perform {
    NSLog(@"%d", 6);
}
```
输出为

```
1
5
6
2
3
4
```
	
##Dispatch Group
在追加到Dispatch Queue中的多个处理全部结束后想执行结束处理的情形，除了使用Serial Dispatch Queue外， 在使用Concurrent Dispatch Queue或同时使用多个Dispatch Queue时，应该使用Dispatch Group。

	dispatch_queue_t queue =
	  		dispatch_get_global_queue(DISPATCH_QUEUE_DEFAULT,0);
	dispatch_group_t group = disptach_group_create();
	dispatch_group_async(group,queue,^{1...});
	dispatch_group_async(group,queue,^{2...});
	dispatch_group_async(group,queue,^{3...});
	dispatch_group_notify(group,dispatch_get_main_queue(),^{End Action});
	
注意：在dispatch_group_notify函数中不管指定怎么样的Dispatch Queue,属于Dispatch Group的处理在追加到block（上面例子的【End Action】）时都已经结束。

所以，对于添加的block是异步请求时，dispatch_group_async在瞬间就完成了，并不会等待着异步请求结束后再notify。对于这种问题，dispatch_group也有对应的方法，dispatch_group_enter & dispatch_group_leave这对组合。

```
dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_enter(group);
[IDCWeatherManager executeWeatherWithCity:@"北京" resultBlock:^(NSString * _Nullable weather, UIImage * _Nullable weatherIcon, BOOL result) { // 自定义异步线程
    NSLog(@"22 == %@", weather);
    dispatch_group_leave(group);
}];
dispatch_group_enter(group);
[IDCWeatherManager executeWeatherWithCity:@"北京" resultBlock:^(NSString * _Nullable weather, UIImage * _Nullable weatherIcon, BOOL result) { // 自定义异步线程
    NSLog(@"33 == %@", weather);
    dispatch_group_leave(group);
}];
dispatch_group_enter(group);
[IDCWeatherManager executeWeatherWithCity:@"北京" resultBlock:^(NSString * _Nullable weather, UIImage * _Nullable weatherIcon, BOOL result) { // 自定义异步线程
    NSLog(@"44 == %@", weather); 
    dispatch_group_leave(group);
}];
dispatch_group_enter(group);
[IDCWeatherManager executeWeatherWithCity:@"北京" resultBlock:^(NSString * _Nullable weather, UIImage * _Nullable weatherIcon, BOOL result) { // 自定义异步线程
    NSLog(@"55 == %@", weather);
    dispatch_group_leave(group);
}];
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@"6-6");
    [IDCWeatherManager executeWeatherWithCity:@"北京" resultBlock:^(NSString * _Nullable weather, UIImage * _Nullable weatherIcon, BOOL result) {
        NSLog(@"66 == %@", weather);
    }];
});
NSLog(@"77");
```

执行顺序就是先 1和7，之后2到5随机，最后才是6-6以及66。

dispatch_group_enter() 和 dispatch_group_leave()必须成对出现，group_enter是将请求任务放入到group后，便一直被group持有，直到碰到group_leave；才会释放出来，只有group中不在持有任何任务后才会调用notify进行回调通知。


##Dispatch Group Wait

	dispatch_group_wait(group,DISPATCH_TIME_FOREVER);

该函数的第二个参数指定超时等待的时间，为dispatch_time_t类型。该源代码使用 **DISPATCH_TIME_FOREVER**，意味着永久等待。只有属于Dispatch Group的处理尚未结束，就回一直等待，中途不能取消。

	disptach_time_t time = dispatch_time(DISPATCH_TIME_NOW,1ull*NSEC_PER_SEC)；
	long result = dispatch_group_wait(group,time);
	返回值为long型
	if(result == 0){
	    // 等待时间结束后，group的全部处理执行结束
	}else{
	    // 等待时间结束后，group的还有未完成的处理
	}
	
修改上述源代码result中的时间，不用等待即可判断属于Dispatch Group的处理是否执行完毕。
	
	long result = dispatch_group_wait(group,DISPATCH_TIME_NOW);

正常情况下不使用dispatch_group_wait，而使用dispatch_group_notify(group,dispatch_get_main_queue(),^{结束后执行的});
可以更好的简化代码。

##Dispatch Barrier Async
在访问数据库或文件时，使用Serial Dispatch Queue可避免数据竞争问题。
但为了高效的进行访问，读取处理追加到Concurrent Dispatch Queue中使用并发读取数据，就容易引起问题。

	 queue 为Concurrent dispatch queue
     queue 其他处理1
     queue 其他处理2
     dispatch_barrier_async(queue,blk_for_writing)
     queue 其他处理3
     queue 其他处理4
     
dispatch_barrier_async函数会等待追加到Concurrent Dispatch Queue上的并行执行的处理全部结束之后，再将指定的处理追加到该Concurrent Dispatch Queue中。然后再由dispatch_barrier_async函数追加的处理执行完毕后，Concurrent Dispatch Queue才恢复为一般的动作，追加到该Concurrent Dispatch Queue的处理又开始并行执行。

上面的执行顺序即为：

处理1 2 执行完 才会执行dispatch_barrier_async，dispatch_barrier_async执行完才会执行 其他处理 3 4。

如果其他处理都是数据库读操作dispatch_barrier_async是数据库写操作，那么这样能保证 3 4 读取的数据是修改（写入）后的，数据保持正确。

值得注意的是;

1. dispatchbarrier\(a)sync只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。
2. 既然在串行队列上跟dispatch_(a)sync效果一样，那就要小心别死锁！

##Dispatch Sync
同步执行，与dispatch_async相反。dispatch_sync 函数不会立即返回，会立即阻塞调用时该函数所在的线程，追加任务到添加的线程中,并等待 block同步执行完成。

此方法不能将block加到当前为*DISPATCH_QUEUE_SERIAL*的线程，会导致死锁。主线程为*DISPATCH_QUEUE_SERIAL*的线程，所以也不能直接加。加入到*DISPATCH_QUEUE_CONCURRENT*的线程汇总没有任何问题。注意通过*dispatch_get_global_queue*获得的线程为*DISPATCH_QUEUE_CONCURRENT*，所以没问题。

如下两种方式都将死锁。

	dispatch_queue_t queue = dispatch_get_main_queue();
	
	dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"dispatch_sync");
    });
    
    // 注：后面类型不写的话默认为DISPATCH_QUEUE_SERIAL
    dispatch_queue_t queue = dispatch_queue_create("serialQueue", DISPATCH_QUEUE_SERIAL); 
    dispatch_async(queue, ^{
        NSLog(@"1");
        dispatch_sync(queue, ^{
            NSLog(@"2");
        });
    });
    
像下面这种情况就不会造成死锁：

```
dispatch_queue_t queue = dispatch_queue_create("serialQueue", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        NSLog(@"1");
        dispatch_sync(queue, ^{
            NSLog(@"2");
        });
    });
dispatch_queue_t t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_async(t, ^{
        NSLog(@"3");
        dispatch_sync(t, ^{
            NSLog(@"4");
        });
    });
```
    
##Dispatch Apply
按照指定的次数将指定的Block追加到指定的Diaptch Queue中，**并等待全部处理执行结束**。

	NSArray *array = @[@"6",@"5",@"4",@"3",@"2",@"1"];
	
    dispatch_apply(array.count, dispatch_get_global_queue(
    	DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
        	NSLog(@"%zu---%@", index, [array objectAtIndex:index]);
    });
    
输出为：（异步输出，内容会变化，但done总是最后的）

	0---6
	1---5
	4---2
	2---4
	3---3
	5---1
	done
	
要避免dispatch_apply的嵌套调用，会发生死锁。
	
	dispatch_queue_t queue =
	 dispatch_queue_create("com.dechao.gcd", DISPATCH_QUEUE_SERIAL);
       
	dispatch_apply(3, queue, ^(size_t i) {
		NSLog(@"apply loop: %zu", i);
   
    	//再来一个dispatch_apply！死锁！      
		dispatch_apply(3, queue, ^(size_t j) {
			NSLog(@"apply loop inside %zu", j);
		});
	});
	
##Dispatch Suspend/Dispatch Resume
当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。

dispatch_suspend 挂起已经追加的处理

dispatch_resume 恢复已经追加的处理

dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。

所以下次想暂停正在队列上运行的block时，还是不要用dispatch_suspend了吧~

##Dispatch Semaphore 
代码性排他，通过计数器来限制当前代码在执行过程中只能有限的线程数执行。

##Dispatch Once
官网介绍：*Executes a block object once and only once for the lifetime of an application.*


**保证在应用程序执行中只执行一次**指定的API。

常用来声明单例，即使在多线程的环境下，也可以保证安全。

dispatch_once_t必须是全局或static变量，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：

	//静态变量，保证只有一份实例，才能确保只执行一次
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		//单例代码 
	});
	
其实就是保证dispatch_once_t只有一份实例。

分析下面的源码输入是什么：

```
// 使用 *dispatch_once* 的方式生成一个单例
@implementation Model

+ (instancetype)sharedInstance {
    static Model *_sharedInstance = nil;
    static dispatch_once_t onceToken;
    if (_sharedInstance == nil) {
        dispatch_once(&onceToken, ^{
            _sharedInstance = [[Model alloc] init];
        });
    }
    return _sharedInstance;
}

@end

```

```
Model *mm = [Model sharedInstance];
NSLog(@"%p", mm);

mm = nil;
NSLog(@"%p", mm);

mm = [Model sharedInstance];
NSLog(@"%p", mm);
```

输出为别为：

```
0x7fea7bd8fd10
0x0
0x7fea7bd8fd10
```

开始时生成的 mm 指向使用单例生成的地址，之后将他置为空，即指针转变方向，指向空地址，之后再次指向单例的地址，因为单例的创建是使用 *static* 方式生成的，所以地址不会变化。

##Dispatch I/O
在读取大文件时，如果将文件分为合适的大小并使用Global Dispatch Queue并行读取数据，读取速度会快不少。现在的输入/输出硬件已经可以做到一次性使用多个线程更快的并列读取，实现这一功能的就是Dispatch I/O和Dispatch Data。
通过使用Dispatch I/O可以并发读写数据，提高效率

##Reference
[GCD使用经验与技巧浅谈](http://tutuge.me/2015/04/03/something-about-gcd/)

[Grand Central Dispatch (GCD) Reference](https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html)

[GCD 深入理解：第一部分](https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md)

[GCD 深入理解：第二部分](https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md)

[Grand Central Dispatch In-Depth: Part 1/2](http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1)

[Grand Central Dispatch In-Depth: Part 2/2](http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2)
