---
layout:     post
title:      Block探究
category: blog
description: A block is an anonymous inline collection of code, and sometimes also called a "closure"。通俗的讲，block就是带有自动变量值的匿名函数。

---

A block is an anonymous inline collection of code, and sometimes also called a "closure"。通俗的讲，block就是带有自动变量值的匿名函数。

##Block的实质
Block语法看起来很特别，但它实际上是作为普通的C语言源代码来处理的。但clang（LLVM编译器）居具有转换为我们可阅读的源代码的功能。通过"clang -rewrite-objc + file's name"选项就能够将含有Block语法的源代码转换为C的源代码。

一段简单的源代码：

	int main() {
    	void (^blk)(void) = ^{
       		printf("Hello World!");
    	};
    	blk();
    	return 0;
	}

通过clang变换为以下形式：

	struct __block_impl {
	  void *isa;
	  int Flags;
	  int Reserved;
	  void *FuncPtr;
	};
	
	struct __main_block_impl_0 {
	  struct __block_impl impl;
	  struct __main_block_desc_0* Desc;
	  __main_block_impl_0(void *fp, 
	  struct __main_block_desc_0 *desc, int flags=0) {
	    impl.isa = &_NSConcreteStackBlock;
	    impl.Flags = flags;
	    impl.FuncPtr = fp;
	    Desc = desc;
	  }
	};
	
	static void __main_block_func_0(
	struct __main_block_impl_0 *__cself) {
        printf("Hello World!");
    }
    
    static struct __main_block_desc_0 {
	  size_t reserved;
	  size_t Block_size;
	} __main_block_desc_0_DATA = { 0, 
		sizeof(struct __main_block_impl_0)
		};

	int main() {
	    void (*blk)(void) = 
	    (void (*)())&__main_block_impl_0(
	    (void *)__main_block_func_0,
	     &__main_block_desc_0_DATA);
	     
	    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)
	    ((__block_impl *)blk);
	    return 0;
	}
	
不想看那长长的一段代码的话直接看这幅结构图：

![block-struct](/images/blog/block/block_1_1.jpg)

*上面的源代码中并没有copy、dispose等，稍后解释*

可以看出，一个block实际有6部分组成;

1. isa指针，所有对象都有该指针，用于实现对象相关的功能。
2. flags，用于按bit位表示一些block的附加信息，本文后面介绍block copy的实现代码可以看到对该变量的使用。
3. reserved，保留变量。
4. invoke，函数指针，指向具体的block实现的函数调用地址。
5. descriptor， 表示该block的附加描述信息，主要是size大小，以及copy和 dispose函数的指针。
6. variables，capture过来的变量，block能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。

对于该block的构造函数,如下代码，

		void (*blk)(void) = 
		(void (*)())&__main_block_impl_0(
		(void *)__main_block_func_0,
		 &__main_block_desc_0_DATA);


去掉转化部分，具体为：

		struct __main_block_impl_0 tmp = 
		__main_block_impl_0(__main_block_func_0,
		 &__main_block_desc_0_DATA);
		 
		struct __main_block_impl_0 *blk = &blk;


该源码将__main_block_impl_0结构体类型的自动变量赋值给__main_block_impl_0结构体指针类型的变量blk。

##Block访问符，__block说明符
Block能够截获自动变量的值，但在实现上不能改写被截获的自动变量的值，因此当编译器在编译过程中检出给被截获的自动变量赋值的操作时，会产生编译错误。

解决这个问题有俩种方法。第一种：**C语言中有一个变量，允许Block改写值**。具体如下：

* 静态变量
* 静态全局变量
* 全局变量

虽然Block语法的匿名函数部分简单的变换为了C语言函数，但从这个变换的函数中访问静态全局变量/全局变量并没有任何改变，可直接使用。

但是静态变量的情况下，转换后的函数本来就设置在含有Block语法的函数外，所以无法从变量作用域访问。

查看下列源代码。

	int global_val = 1;
	static int static_global_val = 3;

	int main(int argc, const char * argv[]) {
	    @autoreleasepool {
	        static int static_val = 5;
	        
	        void (^block)() = ^{
	            global_val *= 1;
	            static_global_val *= 3;
	            static_val *= 5;
	        };
	        
	        block();
	        printf("%d,%d,%d",
	         global_val, static_global_val, static_val);
	    }
	    return 0;
	}

该源代码使用了Block改写全局变量global_val、静态全局变量static_global_val和静态变量static_val。通过clang转换之后如下：
		
	int global_val = 1;
	static int static_global_val = 3;

	struct __main_block_impl_0 {
  		struct __block_impl impl;
  		struct __main_block_desc_0* Desc;
  		int *static_val;
  		__main_block_impl_0(void *fp, 
  		struct __main_block_desc_0 *desc, 
  		int *_static_val, 
  		int flags=0) : static_val(_static_val) {
    		impl.isa = &_NSConcreteStackBlock;
    		impl.Flags = flags;
    		impl.FuncPtr = fp;
    		Desc = desc;
  		}
	};
	
	static void __main_block_func_0(
	struct __main_block_impl_0 *__cself) {
  	int *static_val = __cself->static_val; // bound by copy
            global_val *= 1;
            static_global_val *= 3;
            (*static_val) *= 5;
        }

	static struct __main_block_desc_0 {
	  size_t reserved;
	  size_t Block_size;
	} __main_block_desc_0_DATA = { 0, 
	sizeof(struct __main_block_impl_0)};

	int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ 
    { __AtAutoreleasePool __autoreleasepool; 
        static int static_val = 5;

        void (*block)() = 
        (void (*)())
        &__main_block_impl_0((void *)__main_block_func_0,
                 &__main_block_desc_0_DATA, &static_val);

        ((void (*)(__block_impl *))
        ((__block_impl *)block)->FuncPtr)((__block_impl *)block);
        printf("%d,%d,%d", global_val, static_global_val, static_val);
    }
    return 0;
}
	
	
对于静态变量static_val的访问，查看方法__main_block_func_0，可以看出使用静态变量static_val的指针对其进行访问。将静态变量static_val的指针传递给__main_block_func_0结构体的构造函数并保存。这是超出作用域使用变量的最简单的方法。

解决Block不能保存值的**第二种方法是使用"__block"说明符**。更准确的表述方式为"__block存储域类说明符"。

在编译错误的变量前加上__block说明符
	
	__block int val = 3;
   	void (^block)() = ^{
   	    val = 5;
   	};

对该源代码进行编译，结果如下。

	struct __Block_byref_val_0 {
  		void *__isa;
		__Block_byref_val_0 *__forwarding;
 		int __flags;
 		int __size;
 		int val;
	};

	struct __main_block_impl_0 {
	  struct __block_impl impl;
	  struct __main_block_desc_0* Desc;
	  __Block_byref_val_0 *val; // by ref
	  __main_block_impl_0(void *fp, 
	  struct __main_block_desc_0 *desc,
	  __Block_byref_val_0 *_val, int flags=0) : val(_val->__forwarding) {
	    impl.isa = &_NSConcreteStackBlock;
	    impl.Flags = flags;
	    impl.FuncPtr = fp;
	    Desc = desc;
	  }
	};
	
	static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
	__Block_byref_val_0 *val = __cself->val; // bound by ref
            (val->__forwarding->val) = 5;
        }
        
	static void __main_block_copy_0
	(struct __main_block_impl_0*dst, 
	struct __main_block_impl_0*src) {
		_Block_object_assign((void*)&dst->val, 
		(void*)src->val, 
		8/*BLOCK_FIELD_IS_BYREF*/);
	}

	static void __main_block_dispose_0(
		struct __main_block_impl_0*src) {
		_Block_object_dispose((void*)src->val, 8/*BLOCK_FIELD_IS_BYREF*/);
	}

	static struct __main_block_desc_0 {
	  size_t reserved;
	  size_t Block_size;
	  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
	  void (*dispose)(struct __main_block_impl_0*);
	} __main_block_desc_0_DATA = {
	 0,
	 sizeof(struct __main_block_impl_0), 
	 __main_block_copy_0, 
	 __main_block_dispose_0
	};

	int main(int argc, const char * argv[]) {
	    /* @autoreleasepool */ 
	    { __AtAutoreleasePool __autoreleasepool; 
	        __attribute__((__blocks__(byref))) 
	        __Block_byref_val_0 val = {
	        	(void*)0,
	        	(__Block_byref_val_0 *)&val, 
	        	0, 
	        	sizeof(__Block_byref_val_0), 
	        	3
	        };
	        void (*block)() = 
	        (void (*)())&__main_block_impl_0(
	        (void *)__main_block_func_0, 
	        &__main_block_desc_0_DATA, 
	        (__Block_byref_val_0 *)&val, 
	        570425344);
	        ((void (*)(__block_impl *))
	        ((__block_impl *)block)->FuncPtr)((__block_impl *)block);
	    }
	    return 0;
	}

__block变量var变成了结构体实例。__block变量也同Block一样变成__Block_byref_val_0结构体类型的自动变量，即栈上生成的__Block_byref_val_0结构体实例。这里可以看出上面留下的问题，cope和dispose是因为__block在clang之后出现的。

初始化block的时候，对__Block_byref_val_0结构体赋值，即为初始化的值。刚刚在Block中向静态变量赋值时，使用了该静态变量的指针。而向__block变量赋值要比这个复杂的多。Block的__main_block_impl_0结构体实例持有指向__block变量的__Block_byref_val_0结构体实例的指针。

__Block_byref_val_0结构体实例的成员变量__forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量var。（成员变量var是该实例自身持有的变量，它相当于原自动变量。）如图所示。

![block-struct](/images/blog/block/block_2_1.jpg)

另外，__block变量的__Block_byref_val_0结构体并不在Block的__main_block_impl_0结构体中，这样做是为了在多个Block中使用__block变量。我们看一下下面的源代码。

	__block int var = 1;
        
   	void (^blk0)() = ^{
   		var = 0;
   	};
   
   	void (^blk1)() = ^{
   		var = 1;
   	};
   	
Block类型变量blk0和blk1访问__block变量var。将转换的之后的结果摘录出来。

	struct __Block_byref_var_0 {
		void *__isa;
		__Block_byref_var_0 *__forwarding;
		int __flags;
		int __size;
	 	int var;
	};
	
	void (*blk0)() = (void (*)())&__main_block_impl_0(
	(void *)__main_block_func_0, 
	&__main_block_desc_0_DATA, 
	(__Block_byref_var_0 *)&var, 
	570425344
	);

    void (*blk1)() = (void (*)())&__main_block_impl_1(
    (void *)__main_block_func_1,
     &__main_block_desc_1_DATA, 
     (__Block_byref_var_0 *)&var, 
     570425344
     );
     
俩个Block都是使用了__Block_byref_var_0结构体实例var的指针。这样一来就可以从多个Block中使用同一个__block变量。当然，反过来从一个Block中使用多个__block变量也是可以的。只要增加Block的结构体成员变量与构造函数的参数，便可对应多个使用多个__block变量。
   	
##Block存储域

通过前面的说明可知，Block转换为Block的结构体类型的自动变量，__block变量转换为__block变量的结构体类型的自动变量。所谓结构体类型的自动变量，即栈上生成的该结构体的实例。如下表所示。

|名称|实质|
|:---:|:---:|
|Block|栈上Block的结构体实例|
|__block变量|栈上__block变量的结构体实例|


之前的clang之后的代码中，出现了
```
impl.isa = &_NSConcreteStackBlock;
```
，说明该Block的类型为_NSConcreteStackBlock。同时与之相对应的类有：

* _NSConcreteStackBlock
* _NSConcreteGlobalBlock
* _NSConcreteMallocBlock

对应的存储区域如下表。

|类|对应的存储域|
|:---:|:---:|
|_NSConcreteStackBlock|栈|
|_NSConcreteGlobalBlock|程序中的数据区域（.data区）|
|_NSConcreteMallocBlock|堆|

应用程序的内存分配如下图。
![block](/images/blog/block/block_3_1.jpg)

到现为止出现的Block例子使用的都是_NSConcreteStackBlock类，且都设置在栈上。在记述全局变脸的地方使用Block语法时，生成的Block为_NSConcreteGlobalBlock类对象。例如：

	void (^blk)() = ^{
    	NSLog(@"Hello World!");
	};
	int main(int argc, const char * argv[]) {
       return 0;
	}

此源代码通过使用全局变量blk来使用Block语法。该Block的类**在ARC和非ARC下**都为*_NSConcreteGlobalBlock*。此Block即该Block的结构体实例设置在程序的数据区域中。由此Block的结构体实例的内容不依赖于执行时的状态，或者说为该Block不会capture变量，所以整个程序中只需要一个实例。因此将Block的结构体实例设置在与全局变量相同的数据区域中。

只在截获自动变量时，Block的结构体实例截获的值才会根据执行时的状态变化。例如一下源代码中，虽然多次使用同一个Block语法blk，但每个for循环中截获的自动变量的值都不同。

	typedef int (^blk_t)(int);
	int main(int argc, const char * argv[]) {
    	@autoreleasepool {        
           for (int rate = 0; rate < 10; rate++) {
           		blk_t blk = ^(int count) {
             	  		return rate * count;
            	  	};            
           		blk_t blk2 = ^(int count) {
                		return count;
            		};
        	}
    	}
    	return 0;
	}
	
在非ARC下，blk为_NSConcreteStackBlock，blk2为_NSConcreteGlobalBlock

在ARC下，blk为_NSConcreteMallocBlock，blk2为_NSConcreteGlobalBlock

这里先给出ARC下的状态，稍后解释ARC下的不同，先重点关注非ARC。

配置在全局变量上的Block，从变量作用域外也可以通过指针安全的访问。但设置在栈上的Block，如果其所属的变量作用域结束，则该__block变量也会被废弃，如下图所示。
![block](/images/blog/block/block_3_2.jpg)

Block提供了将Block和__block变量从栈上复制到堆上的方法来解决这个问题。将配置在栈上的Block赋值到堆上，这样即使Block语法记述的变量作用域结束，堆上的Block还可以继续存在。如下图所示。
![block](/images/blog/block/block_3_3.jpg)

复制到堆上的Block将_NSConcreteMallocBlock类对象写入Block的结构体实例的成员变量isa。

```
impl.isa = &_NSConcreteMallocBlock;
```

而__block变量的结构体成员变量__forwarding可以实现无论__block变量配置在栈上还是堆上都能正确访问__block变量。

有时在__block变量配置在堆上的状态下，也可以访问栈上的__block变量。在此情形下，只要栈上的结构体实例成员变量__forwarding指向堆上的结构体实例，那么不管是从栈上的__block变量还是从堆上的__block变量都能够正确访问。

那么Blocks提供的复制方法究竟是什么呢？实际上当ARC有效时，大多数情形下编译器会恰当的进行判断，自动生成将Block从栈上复制到堆上的代码。分析下面源代码。

	typedef int (^blk_t)(int);
	blk_t func ( int rate )
	{
    	return ^(int count){
        	return rate * count;
    	};
	}

该源代码为返回配置在栈上的Block函数。即程序执行中从该函数返回函数调用方时变量作用域结束，因此栈上的Block也被废弃。

上面源代码是在ARC环境下(clang命令需要声明为ARC环境，clang -fobjc-arc -rewrite-objc file's name)，非ARC下会编译错误，提示Returning block that lives on the local stack。但是可以通过增加临时变量的方式使得编译通过。

	typedef int (^blk_t)(int);
	blk_t func (int rate) {
	    blk_t tmp = ^(int count) {
	        return count * rate;
	    };
	    return tmp;
	}
	int main(int argc, const char * argv[]) {
	    return 0;
	}

把原来的返回值赋给一个变量，然后再返回这个变量。不过虽然编译通过了，这个返回的Block作用域仍是在函数栈中的，因此一旦函数运行完毕后再使用这个Block很可能会引发BAD_ACCESS错误。




   	


		