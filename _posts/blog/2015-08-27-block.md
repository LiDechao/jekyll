---
layout:     post
title:      Block探究
category: blog
description: A block is an anonymous inline collection of code, and sometimes also called a "closure"。通俗的讲，block就是带有自动变量值的匿名函数。

---

A block is an anonymous inline collection of code, and sometimes also called a "closure"。通俗的讲，block就是带有自动变量值的匿名函数。

##Block的实质
Block语法看起来很特别，但它实际上是作为普通的C语言源代码来处理的。但clang（LLVM编译器）居具有转换为我们可阅读的源代码的功能。通过"clang -rewrite-objc + file's name"选项就能够将含有Block语法的源代码转换为C的源代码。

一段简单的源代码：

	int main() {
    	void (^blk)(void) = ^{
       		printf("Hello World!");
    	};
    	blk();
    	return 0;
	}

通过clang变换为以下形式：

	struct __block_impl {
	  void *isa;
	  int Flags;
	  int Reserved;
	  void *FuncPtr;
	};
	
	struct __main_block_impl_0 {
	  struct __block_impl impl;
	  struct __main_block_desc_0* Desc;
	  __main_block_impl_0(void *fp, 
	  struct __main_block_desc_0 *desc, int flags=0) {
	    impl.isa = &_NSConcreteStackBlock;
	    impl.Flags = flags;
	    impl.FuncPtr = fp;
	    Desc = desc;
	  }
	};
	
	static void __main_block_func_0(
	struct __main_block_impl_0 *__cself) {
        printf("Hello World!");
    }
    
    static struct __main_block_desc_0 {
	  size_t reserved;
	  size_t Block_size;
	} __main_block_desc_0_DATA = { 0, 
		sizeof(struct __main_block_impl_0)
		};

	int main() {
	    void (*blk)(void) = 
	    (void (*)())&__main_block_impl_0(
	    (void *)__main_block_func_0,
	     &__main_block_desc_0_DATA);
	     
	    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)
	    ((__block_impl *)blk);
	    return 0;
	}
	
不想看那长长的一段代码的话直接看这幅结构图：

![block-struct](/images/blog/block-struct.jpg)

*上面的源代码中并没有copy、dispose等，稍后解释*

可以看出，一个block实际有6部分组成;

1. isa指针，所有对象都有该指针，用于实现对象相关的功能。
2. flags，用于按bit位表示一些block的附加信息，本文后面介绍block copy的实现代码可以看到对该变量的使用。
3. reserved，保留变量。
4. invoke，函数指针，指向具体的block实现的函数调用地址。
5. descriptor， 表示该block的附加描述信息，主要是size大小，以及copy和 dispose函数的指针。
6. variables，capture过来的变量，block能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。

对于该block的构造函数,如下代码，

		void (*blk)(void) = 
		(void (*)())&__main_block_impl_0(
		(void *)__main_block_func_0,
		 &__main_block_desc_0_DATA);


去掉转化部分，具体为：

		struct __main_block_impl_0 tmp = 
		__main_block_impl_0(__main_block_func_0,
		 &__main_block_desc_0_DATA);
		 
		struct __main_block_impl_0 *blk = &blk;


该源码将__main_block_impl_0结构体类型的自动变量赋值给__main_block_impl_0结构体指针类型的变量blk。

##Block访问符，__block说明符
Block能够截获自动变量的值，但在实现上不能改写被截获的自动变量的值，因此当编译器在编译过程中检出给被截获的自动变量赋值的操作时，会产生编译错误。

解决这个问题有俩种方法。第一种：**C语言中有一个变量，允许Block改写值**。具体如下：

* 静态变量
* 静态全局变量
* 全局变量

虽然Block语法的匿名函数部分简单的变换为了C语言函数，但从这个变换的函数中访问静态全局变量/全局变量并没有任何改变，可直接使用。

但是静态变量的情况下，转换后的函数本来就设置在含有Block语法的函数外，所以无法从变量作用域访问。

查看下列源代码。

	int global_val = 1;
	static int static_global_val = 3;

	int main(int argc, const char * argv[]) {
	    @autoreleasepool {
	        static int static_val = 5;
	        
	        void (^block)() = ^{
	            global_val *= 1;
	            static_global_val *= 3;
	            static_val *= 5;
	        };
	        
	        block();
	        printf("%d,%d,%d",
	         global_val, static_global_val, static_val);
	    }
	    return 0;
	}

该源代码使用了Block改写全局变量global_val、静态全局变量static_global_val和静态变量static_val。通过clang转换之后如下：
		
	int global_val = 1;
	static int static_global_val = 3;

	struct __main_block_impl_0 {
  		struct __block_impl impl;
  		struct __main_block_desc_0* Desc;
  		int *static_val;
  		__main_block_impl_0(void *fp, 
  		struct __main_block_desc_0 *desc, 
  		int *_static_val, 
  		int flags=0) : static_val(_static_val) {
    		impl.isa = &_NSConcreteStackBlock;
    		impl.Flags = flags;
    		impl.FuncPtr = fp;
    		Desc = desc;
  		}
	};
	
	static void __main_block_func_0(
	struct __main_block_impl_0 *__cself) {
  	int *static_val = __cself->static_val; // bound by copy
            global_val *= 1;
            static_global_val *= 3;
            (*static_val) *= 5;
        }

	static struct __main_block_desc_0 {
	  size_t reserved;
	  size_t Block_size;
	} __main_block_desc_0_DATA = { 0, 
	sizeof(struct __main_block_impl_0)};

	int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ 
    { __AtAutoreleasePool __autoreleasepool; 
        static int static_val = 5;

        void (*block)() = 
        (void (*)())
        &__main_block_impl_0((void *)__main_block_func_0,
                 &__main_block_desc_0_DATA, &static_val);

        ((void (*)(__block_impl *))
        ((__block_impl *)block)->FuncPtr)((__block_impl *)block);
        printf("%d,%d,%d", global_val, static_global_val, static_val);
    }
    return 0;
}
	
	
对于静态变量static_val的访问，查看方法__main_block_func_0，可以看出使用静态变量static_val的指针对其进行访问。将静态变量static_val的指针传递给__main_block_func_0结构体的构造函数并保存。这是超出作用域使用变量的最简单的方法。

解决Block不能保存值的**第二种方法是使用"__block"说明符**。更准确的表述方式为"__block存储域类说明符"。

在编译错误的变量前加上__block说明符
	
	__block int val = 3;
   	void (^block)() = ^{
   	    val = 5;
   	};

对该源代码进行编译，结果如下。

	struct __Block_byref_val_0 {
  		void *__isa;
		__Block_byref_val_0 *__forwarding;
 		int __flags;
 		int __size;
 		int val;
	};

	struct __main_block_impl_0 {
	  struct __block_impl impl;
	  struct __main_block_desc_0* Desc;
	  __Block_byref_val_0 *val; // by ref
	  __main_block_impl_0(void *fp, 
	  struct __main_block_desc_0 *desc,
	  __Block_byref_val_0 *_val, int flags=0) : val(_val->__forwarding) {
	    impl.isa = &_NSConcreteStackBlock;
	    impl.Flags = flags;
	    impl.FuncPtr = fp;
	    Desc = desc;
	  }
	};
	
	static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
	__Block_byref_val_0 *val = __cself->val; // bound by ref
            (val->__forwarding->val) = 5;
        }
        
	static void __main_block_copy_0
	(struct __main_block_impl_0*dst, 
	struct __main_block_impl_0*src) {
		_Block_object_assign((void*)&dst->val, 
		(void*)src->val, 
		8/*BLOCK_FIELD_IS_BYREF*/);
	}

	static void __main_block_dispose_0(
		struct __main_block_impl_0*src) {
		_Block_object_dispose((void*)src->val, 8/*BLOCK_FIELD_IS_BYREF*/);
	}

	static struct __main_block_desc_0 {
	  size_t reserved;
	  size_t Block_size;
	  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
	  void (*dispose)(struct __main_block_impl_0*);
	} __main_block_desc_0_DATA = {
	 0,
	 sizeof(struct __main_block_impl_0), 
	 __main_block_copy_0, 
	 __main_block_dispose_0
	};

	int main(int argc, const char * argv[]) {
	    /* @autoreleasepool */ 
	    { __AtAutoreleasePool __autoreleasepool; 
	        __attribute__((__blocks__(byref))) 
	        __Block_byref_val_0 val = {
	        	(void*)0,
	        	(__Block_byref_val_0 *)&val, 
	        	0, 
	        	sizeof(__Block_byref_val_0), 
	        	3
	        };
	        void (*block)() = 
	        (void (*)())&__main_block_impl_0(
	        (void *)__main_block_func_0, 
	        &__main_block_desc_0_DATA, 
	        (__Block_byref_val_0 *)&val, 
	        570425344);
	        ((void (*)(__block_impl *))
	        ((__block_impl *)block)->FuncPtr)((__block_impl *)block);
	    }
	    return 0;
	}

__block变量var变成了结构体实例。__block变量也同Block一样变成__Block_byref_val_0结构体类型的自动变量，即栈上生成的__Block_byref_val_0结构体实例。这里可以看出上面留下的问题，cope和dispose是因为__block在clang之后出现的。

初始化block的时候，对__Block_byref_val_0结构体赋值，即为初始化的值。刚刚在Block中向静态变量赋值时，使用了该静态变量的指针。而向__block变量赋值要比这个复杂的多。Block的__main_block_impl_0结构体实例持有指向__block变量的__Block_byref_val_0结构体实例的指针。

__Block_byref_val_0结构体实例的成员变量__forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量var。（成员变量var是该实例自身持有的变量，它相当于原自动变量。）如图所示。

![block-struct](/images/blog/block-byref-var-0.jpg)

另外，__block变量的__Block_byref_val_0结构体并不在Block的__main_block_impl_0结构体中，这样做是为了在多个Block中使用__block变量。我们看一下下面的源代码。

	__block int var = 1;
        
   	void (^blk0)() = ^{
   		var = 0;
   	};
   
   	void (^blk1)() = ^{
   		var = 1;
   	};
   	
Block类型变量blk0和blk1访问__block变量var。将转换的之后的结果摘录出来。

	struct __Block_byref_var_0 {
		void *__isa;
		__Block_byref_var_0 *__forwarding;
		int __flags;
		int __size;
	 	int var;
	};
	
	void (*blk0)() = (void (*)())&__main_block_impl_0(
	(void *)__main_block_func_0, 
	&__main_block_desc_0_DATA, 
	(__Block_byref_var_0 *)&var, 
	570425344
	);

    void (*blk1)() = (void (*)())&__main_block_impl_1(
    (void *)__main_block_func_1,
     &__main_block_desc_1_DATA, 
     (__Block_byref_var_0 *)&var, 
     570425344
     );
     
俩个Block都是使用了__Block_byref_var_0结构体实例var的指针。这样一来就可以从多个Block中使用同一个__block变量。当然，反过来从一个Block中使用多个__block变量也是可以的。只要增加Block的结构体成员变量与构造函数的参数，便可对应多个使用多个__block变量。
   	
##block实质
block实质
   	


		