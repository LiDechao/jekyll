---
layout: post
title: iOS动画之Layer
description: layer
headline: layer
modified: 2016-12-05                 
category: iOS
tags: [iOS,Animation]
image: 
imagefeature: picture-37.jpg
comments: true
mathjax:
---

<section id="table-of-contents" class="toc">
  <header>
    <h1>Features</h1>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->

## contents属性
CALayer有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。

所以基本的使用情况：

<pre class="sunlight-highlight-objective-c">
layer.contents = (__bridge id)image.CGImage;
</pre>

 > 不过貌似本地测试的时候只是强转了id也能生效
 
### contentsGravity
 
同UIImageView一样，在大小不合适的情况下，会出现照片的适应性问题。解决方法就是把contentMode属性设置成更合适的值，像这样：

<pre class="sunlight-highlight-objective-c">
view.contentMode = UIViewContentModeScaleAspectFit;
</pre>

这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。

CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。

和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。

<pre class="sunlight-highlight-objective-c">
self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
</pre>

### maskToBounds

默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。
UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，图片就在边界里啦～

还有一些其他属性，诸如 `contentsScale`、`contentsRect`、`contentsCenter` 、等觉得是并不常用，暂不做介绍了。

## CAShapeLayer

CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：

 * 渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。
 * 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。
 * 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉。
 * 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。

### 创建一个CGPath

CAShapeLayer可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如`lineWith`（线宽，用点表示单位），`lineCap`（线条结尾的样子），和`lineJoin`（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。

下面的代码用一个CAShapeLayer渲染一个简单的火柴人。CAShapeLayer属性是CGPathRef类型，但是我们用UIBezierPath帮助类创建了图层路径，这样我们就不用考虑人工释放CGPath了。


<pre class="sunlight-highlight-objective-c">
UIView *containerView = [[UIView alloc] initWithFrame:self.view.bounds];
containerView.backgroundColor = [UIColor lightGrayColor];
[self.view addSubview:containerView];
    
// create path
UIBezierPath *path = [[UIBezierPath alloc] init];
[path moveToPoint:CGPointMake(175, 100)];
    
[path addArcWithCenter:CGPointMake(150, 100)
                radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];
[path moveToPoint:CGPointMake(150, 125)];
[path addLineToPoint:CGPointMake(150, 175)];
[path addLineToPoint:CGPointMake(125, 225)];
[path moveToPoint:CGPointMake(150, 175)];
[path addLineToPoint:CGPointMake(175, 225)];
[path moveToPoint:CGPointMake(100, 150)];
[path addLineToPoint:CGPointMake(200, 150)];
    
// create shapr layer
CAShapeLayer *layer = [CAShapeLayer layer];
layer.strokeColor = [UIColor redColor].CGColor;
layer.fillColor = [UIColor clearColor].CGColor;
layer.lineWidth = 5;
layer.lineJoin = kCALineJoinRound;
layer.lineCap = kCALineCapRound;
layer.path = path.CGPath;
    
// add layer to view
[containerView.layer addSublayer:layer];
</pre>

<figure>
	<a href="{{ site.url }}/images/layer/layer_man.jpg"><img src="{{ site.url }}/images/layer/layer_man.jpg"></a>
	<figcaption>CAShapeLayer CGPath</figcaption>
</figure>

### 圆角

CAShapeLayer为创建圆角视图提供了一个方法，就是CALayer的cornerRadius属性。虽然使用CAShapeLayer类需要更多的工作，但是它有一个优势就是可以单独指定每个角。

我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上UIBezierPath有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：

<pre class="sunlight-highlight-objective-c">
// define path parameters
CGRect rect = CGRectMake(0, 0, 100, 100);
UIRectCorner corners = UIRectCornerTopRight |
                       UIRectCornerBottomRight | UIRectCornerBottomLeft;
CGSize radii = CGSizeMake(30, 30);
// create path
UIBezierPath *corPath = [UIBezierPath bezierPathWithRoundedRect:rect
                                              byRoundingCorners:corners
                                                    cornerRadii:radii];
    
CAShapeLayer *cornerLayer = [CAShapeLayer layer];
cornerLayer.frame = CGRectMake(100, 260, 100, 100);
cornerLayer.path = corPath.CGPath;
cornerLayer.fillColor = [UIColor blueColor].CGColor;
[containerView.layer addSublayer:cornerLayer];
</pre>

<figure>
	<a href="{{ site.url }}/images/layer/layer_corner.jpg"><img src="{{ site.url }}/images/layer/layer_corner.jpg"></a>
	<figcaption>CAShapeLayer Corner</figcaption>
</figure>

我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个子视图。

<!--## CATextLayer

## CATransformLayer

## CAGradientLayer

## CAReplicatorLayer

## CAScrollLayer

## CATiledLayer

## CAEmitterLayer

## CAEAGLLayer

## AVPlayerLayer-->

## 查考

[iOS核心动画高级技巧](https://zsisme.gitbooks.io/ios-/content/)


