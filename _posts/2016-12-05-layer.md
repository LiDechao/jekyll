---
layout: post
title: iOS动画之Layer
description: layer
headline: layer
modified: 2016-12-05                 
category: iOS
tags: [iOS,Animation]
image: 
imagefeature: picture-37.jpg
comments: true
mathjax:
---

<section id="table-of-contents" class="toc">
  <header>
    <h1>Features</h1>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->

## contents属性
CALayer有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。

所以基本的使用情况：

<pre class="sunlight-highlight-objective-c">
layer.contents = (__bridge id)image.CGImage;
</pre>

 > 不过貌似本地测试的时候只是强转了id也能生效
 
### contentsGravity
 
同UIImageView一样，在大小不合适的情况下，会出现照片的适应性问题。解决方法就是把contentMode属性设置成更合适的值，像这样：

<pre class="sunlight-highlight-objective-c">
view.contentMode = UIViewContentModeScaleAspectFit;
</pre>

这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。

CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。

和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。

<pre class="sunlight-highlight-objective-c">
self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
</pre>

### maskToBounds

默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。
UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，图片就在边界里啦～

还有一些其他属性，诸如 `contentsScale`、`contentsRect`、`contentsCenter` 、等觉得是并不常用，暂不做介绍了。

<!--## CAShapeLayer

## CATextLayer

## CATransformLayer

## CAGradientLayer

## CAReplicatorLayer

## CAScrollLayer

## CATiledLayer

## CAEmitterLayer

## CAEAGLLayer

## AVPlayerLayer-->

## 查考

[iOS核心动画高级技巧](https://zsisme.gitbooks.io/ios-/content/)


