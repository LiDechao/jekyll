---
layout: post
title: iOS动画之Layer
description: layer
headline: layer
modified: 2016-12-05                 
category: iOS
tags: [iOS,Animation]
image: 
imagefeature: picture-37.jpg
comments: true
mathjax:
---

<section id="table-of-contents" class="toc">
  <header>
    <h1>Features</h1>
  </header>
<div id="drawer" markdown="1">
*  Auto generated table of contents
{:toc}
</div>
</section><!-- /#table-of-contents -->

## contents属性
CALayer有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。

所以基本的使用情况：

<pre class="sunlight-highlight-objective-c">
layer.contents = (__bridge id)image.CGImage;
</pre>

 > 不过貌似本地测试的时候只是强转了id也能生效
 
### contentsGravity
 
同UIImageView一样，在大小不合适的情况下，会出现照片的适应性问题。解决方法就是把contentMode属性设置成更合适的值，像这样：

<pre class="sunlight-highlight-objective-c">
view.contentMode = UIViewContentModeScaleAspectFit;
</pre>

这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。

CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。

和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。

<pre class="sunlight-highlight-objective-c">
self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
</pre>

### maskToBounds

默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。
UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，图片就在边界里啦～

还有一些其他属性，诸如 `contentsScale`、`contentsRect`、`contentsCenter` 、等觉得是并不常用，暂不做介绍了。

## CAShapeLayer

CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：

 * 渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。
 * 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。
 * 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉。
 * 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。

### 创建一个CGPath

CAShapeLayer可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如`lineWith`（线宽，用点表示单位），`lineCap`（线条结尾的样子），和`lineJoin`（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。

下面的代码用一个CAShapeLayer渲染一个简单的火柴人。CAShapeLayer属性是CGPathRef类型，但是我们用UIBezierPath帮助类创建了图层路径，这样我们就不用考虑人工释放CGPath了。


<pre class="sunlight-highlight-objective-c">
UIView *containerView = [[UIView alloc] initWithFrame:self.view.bounds];
containerView.backgroundColor = [UIColor lightGrayColor];
[self.view addSubview:containerView];
    
// create path
UIBezierPath *path = [[UIBezierPath alloc] init];
[path moveToPoint:CGPointMake(175, 100)];
    
[path addArcWithCenter:CGPointMake(150, 100)
                radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];
[path moveToPoint:CGPointMake(150, 125)];
[path addLineToPoint:CGPointMake(150, 175)];
[path addLineToPoint:CGPointMake(125, 225)];
[path moveToPoint:CGPointMake(150, 175)];
[path addLineToPoint:CGPointMake(175, 225)];
[path moveToPoint:CGPointMake(100, 150)];
[path addLineToPoint:CGPointMake(200, 150)];
    
// create shapr layer
CAShapeLayer *layer = [CAShapeLayer layer];
layer.strokeColor = [UIColor redColor].CGColor;
layer.fillColor = [UIColor clearColor].CGColor;
layer.lineWidth = 5;
layer.lineJoin = kCALineJoinRound;
layer.lineCap = kCALineCapRound;
layer.path = path.CGPath;
    
// add layer to view
[containerView.layer addSublayer:layer];
</pre>

<figure>
	<a href="{{ site.url }}/images/layer/layer_man.jpg"><img src="{{ site.url }}/images/layer/layer_man.jpg"></a>
	<figcaption>CAShapeLayer CGPath</figcaption>
</figure>

### 圆角

CAShapeLayer为创建圆角视图提供了一个方法，就是CALayer的cornerRadius属性。虽然使用CAShapeLayer类需要更多的工作，但是它有一个优势就是可以单独指定每个角。

我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上UIBezierPath有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：

<pre class="sunlight-highlight-objective-c">
// define path parameters
CGRect rect = CGRectMake(0, 0, 100, 100);
UIRectCorner corners = UIRectCornerTopRight |
                       UIRectCornerBottomRight | UIRectCornerBottomLeft;
CGSize radii = CGSizeMake(30, 30);
// create path
UIBezierPath *corPath = [UIBezierPath bezierPathWithRoundedRect:rect
                                              byRoundingCorners:corners
                                                    cornerRadii:radii];
    
CAShapeLayer *cornerLayer = [CAShapeLayer layer];
cornerLayer.frame = CGRectMake(100, 260, 100, 100);
cornerLayer.path = corPath.CGPath;
cornerLayer.fillColor = [UIColor blueColor].CGColor;
[containerView.layer addSublayer:cornerLayer];
</pre>

<figure>
	<a href="{{ site.url }}/images/layer/layer_corner.jpg"><img src="{{ site.url }}/images/layer/layer_corner.jpg"></a>
	<figcaption>CAShapeLayer Corner</figcaption>
</figure>

我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个子视图。

## CAEmitterLayer

在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。

CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个例子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在CAEmitterCell类的头文件中找到。

### 类似于facebook的点赞效果：(这里就不加放大缩小的效果了)

<figure>
	<a href="{{ site.url }}/images/layer/layer_support.gif"><img src="{{ site.url }}/images/layer/layer_support.gif"></a>
	<figcaption> CAEmitterLayer </figcaption>
</figure>

代码如下：


<pre class="sunlight-highlight-objective-c">
CAEmitterCell *explosionCell = [CAEmitterCell emitterCell];
// The name of the cell，用于构建key paths。这也是后面手动控制动画开始和结束的关键。
explosionCell.name           = @"explosion";
explosionCell.alphaRange     = 0.10;
explosionCell.alphaSpeed     = -1.0;
// 下面两个属性如果只用了lifetime那么粒子的存活时间就是固定的，比如lifetime=10,那么粒子10s秒后就消失了。
// 如果使用了lifetimeRange，比如lifetimeRange=5，那么粒子的存活时间就是在5s~15s这个范围内消失。
explosionCell.lifetime       = 0.7; // 粒子存活的时间,以秒为单位
explosionCell.lifetimeRange  = 0.3; // 可以为这个粒子存活的时间再指定一个范围
explosionCell.birthRate      = 0; // 每秒生成多少个粒子
// 粒子平均初始速度。正数表示竖直向上，负数竖直向下
explosionCell.velocity       = 40.00;
// 可以再指定一个范围
explosionCell.velocityRange  = 10.00;
explosionCell.scale          = 0.03;
explosionCell.scaleRange     = 0.02;
explosionCell.contents       = (id)[UIImage imageNamed:@"Sparkle"].CGImage;
    
self.explosionLayer               = [CAEmitterLayer layer];
self.explosionLayer.name          = @"emitterLayer";
// 发射源的形状
self.explosionLayer.emitterShape  = kCAEmitterLayerCircle;
// 发射源的发射模式
self.explosionLayer.emitterMode   = kCAEmitterLayerOutline;
//发射源大小。注意除了宽和高之外，还有纵向深度emitterDepth
self.explosionLayer.emitterSize   = CGSizeMake(10, 0);
self.explosionLayer.emitterCells  = @[explosionCell];
self.explosionLayer.renderMode    = kCAEmitterLayerOldestFirst;
self.explosionLayer.masksToBounds = NO;
self.explosionLayer.position      = CGPointMake(10, 10);	// 发射源位置
self.explosionLayer.zPosition     = -1;	// 发射源位置
[self.button.layer addSublayer:self.explosionLayer];
    
[self.button addTarget:self action:@selector(startC) forControlEvents:UIControlEventTouchUpInside];
</pre>

<pre class="sunlight-highlight-objective-c">
- (void)startC {
    //进入下一个动作
//    [self performSelector:@selector(explode) withObject:nil afterDelay:0.2];
    
//    //explosionLayer开始时间
    self.explosionLayer.beginTime = CACurrentMediaTime();
    //explosionLayer每秒喷射的2500个
    //CAEmitterLayer 根据自己的 emitterCells 属性找到名叫 explosion 的 cell，
    //并设置它的 birthRate 为 500。从而间接地控制了动画的开始。
    [self.explosionLayer setValue:@2500 forKeyPath:@"emitterCells.explosion.birthRate"];
    //停止喷射
    [self performSelector:@selector(stop) withObject:nil afterDelay:0.1];
}
</pre>

<pre class="sunlight-highlight-objective-c">
/**
 *  大量喷射
 */
- (void)explode {
    //explosionLayer开始时间
    self.explosionLayer.beginTime = CACurrentMediaTime();
    //explosionLayer每秒喷射的2500个
    [self.explosionLayer setValue:@2500 forKeyPath:@"emitterCells.explosion.birthRate"];
    //停止喷射
    [self performSelector:@selector(stop) withObject:nil afterDelay:0.1];
}
/**
 *  停止喷射
 */
- (void)stop {
    [self.explosionLayer setValue:@0 forKeyPath:@"emitterCells.explosion.birthRate"];
}
</pre>

* `emitterShape`，发射源的形状，平常用的多的比如 emitterShape 的 kCAEmitterLayerLine 和 kCAEmitterLayerPoint。这两个从视觉上还是比较好区分的，这决定了你的粒子是从一个点「喷」出来的，还是从一条线上每个点「喷」下来，前者像焰火，后者像瀑布。显然，下雪的效果更像后者。
* `emitterMode` 的 kCAEmitterLayerOutline 表示向外围扩散，如果你的发射源形状是 circle，那么 kCAEmitterLayerOutline 就会以一个圆的方式向外扩散开。又比如你想表达一股蒸汽向上喷的效果，就可以设置 emitterShape 为 kCAEmitterLayerLine ， emitterMode 为 kCAEmitterLayerOutline。

CAEmitterLayer的属性它自己控制着整个例子系统的位置和形状。一些属性比如birthRate，lifetime和celocity，这些属性在CAEmitterCell中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些：

* `preservesDepth`，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层
* `renderMode`，控制着在视觉上粒子图片是如何混合的。

### 下雪的效果

<figure>
	<a href="{{ site.url }}/images/layer/layer_snow.gif"><img src="{{ site.url }}/images/layer/layer_snow.gif"></a>
	<figcaption> CAEmitterLayer </figcaption>
</figure>

代码如下：

<pre class="sunlight-highlight-objective-c">
CAEmitterLayer *snowEmitter = [CAEmitterLayer layer];
    //发射点的位置
snowEmitter.emitterPosition = CGPointMake(CGRectGetWidth(self.view.frame) / 2, -30);
snowEmitter.emitterSize = CGSizeMake(CGRectGetWidth(self.view.frame) * 2, 0.0f);
snowEmitter.emitterShape = kCAEmitterLayerLine; // 发射源的形状
snowEmitter.emitterMode = kCAEmitterLayerOutline;
    
snowEmitter.shadowColor = [UIColor whiteColor].CGColor;
snowEmitter.shadowOffset = CGSizeMake(0.0f, 1.0f);
snowEmitter.shadowRadius = 0.0f;
snowEmitter.shadowOpacity = 1.0f;
    
CAEmitterCell *snowCell = [CAEmitterCell emitterCell];
    
snowCell.birthRate = 1.0f; //每秒出现多少个粒子
snowCell.lifetime = 120.0f; // 粒子的存活时间
snowCell.velocity = -10; //速度
snowCell.velocityRange = 10; // 平均速度
snowCell.yAcceleration = 2;//粒子在y方向上的加速度
snowCell.emissionRange = 0.5f * M_PI; //发射的弧度
snowCell.spinRange = 0.75f * M_PI; // 粒子的平均旋转速度
snowCell.contents = (id)[UIImage imageNamed:@"snow"].CGImage;
snowCell.color = [UIColor colorWithRed:0.6 green:0.658 blue:0.743 alpha:1.0].CGColor;
    
snowEmitter.emitterCells = @[snowCell];
    
[self.view.layer insertSublayer:snowEmitter atIndex:0];  
</pre>

> 有时候返回的时候，layer还未移除，所以会看到部分影像，可以在返回的时候手动移除:

<pre class="sunlight-highlight-objective-c">
for (CALayer *subLayer in self.view.layer.sublayers) {
    if ([subLayer isKindOfClass:[CAEmitterLayer class]]) {
        CAEmitterLayer *la = (CAEmitterLayer *)subLayer;
        [la removeFromSuperlayer];
    }
}
</pre>


<!--

## CATransformLayer

## CAGradientLayer

## CAReplicatorLayer

## CAScrollLayer

## CATiledLayer



## CAEAGLLayer

## AVPlayerLayer-->

## CATextLayer

CATextLayer是文字显示文字的图层，这里不错解释了，

## GitHub地址

[LayerAnimation](https://github.com/LiDechao/LayerAnimation)

## 查考

[iOS核心动画高级技巧](https://zsisme.gitbooks.io/ios-/content/)


